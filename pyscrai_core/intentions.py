"""Intention system for PyScrAI.

Guardrail 6: The Intention Gate (Async/Sync Split)
> Intentions are async, fallible requests. Events are synchronous, immutable facts.
> The Simulation Loop never waits for an LLM.

The Agentic Workflow:
1. **Agent/User** submits an Intention (e.g., "Move to Castle").
2. **Engine** validates it against the *current* Project Schema and State.
3. **Resolution**:
   - Valid -> Converted to immutable Event (queued for Turn).
   - Invalid -> Rejected (Feedback sent back to Agent).

Performance Typing:
- Intentions use dataclasses(slots=True) for internal hot-loop efficiency.
- NOT Pydantic - these are transient, never saved to DB.
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import Enum
from typing import Optional, Any
from .models import generate_intuitive_id


# ============================================================================
# Intention Status
# ============================================================================


class IntentionStatus(str, Enum):
    """Status of an intention in the processing pipeline."""

    PENDING = "pending"  # Waiting for validation
    VALIDATED = "validated"  # Passed validation, ready for Event conversion
    REJECTED = "rejected"  # Failed validation
    BLOCKED = "blocked"  # Interrupted by another entity (e.g., guard)
    CONVERTED = "converted"  # Successfully converted to Event


# ============================================================================
# Base Intention (dataclass for hot-loop performance)
# ============================================================================


@dataclass(slots=True)
class Intention:
    """Async attempt by Actor to change the world.

    Transient. Exists only until resolved by Engine.
    Generated by:
    - **Cognitive Agents** (LLM-driven Actor behavior)
    - **Human Users** (via Forge/Holodeck UI)
    - **System Scripts** (Gamemaster events)

    Design:
    - Uses dataclass(slots=True) for memory efficiency.
    - Converted to Pydantic Event when accepted by Engine.
    """

    source_id: str  # Actor or system agent ID
    priority: int = 1  # Higher = processed first
    id: str = field(default_factory=lambda: generate_intuitive_id("INT"))
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    status: IntentionStatus = IntentionStatus.PENDING
    rejection_reason: Optional[str] = None


# ============================================================================
# Concrete Intention Types
# ============================================================================


@dataclass(slots=True)
class MoveIntention(Intention):
    """Intention to move to a target location.

    Resolution:
    - Validate actor can move (not dead, not restrained).
    - Validate target location exists.
    - Check region version for stale pathing.
    - Convert to MovementEvent if valid.
    """

    target_location_id: str = ""
    # Optional: computed path (may be invalidated if region version changes)
    computed_path: Optional[list[str]] = None
    path_region_version: Optional[int] = None


@dataclass(slots=True)
class AttackIntention(Intention):
    """Intention to attack a target entity.

    Resolution:
    - Validate combat capabilities defined in Project Schema.
    - Check for interrupts (guards, allies).
    - Convert to combat Event if valid.
    """

    target_entity_id: str = ""
    weapon_index: int = 0
    attack_type: Optional[str] = None


@dataclass(slots=True)
class ChangeRelationshipIntention(Intention):
    """Intention to alter the relationship with another entity.

    Replaces specific "Declare War" logic with a generic system.
    
    Resolution:
    - Validate source stability/resources (based on Project Schema).
    - Check for existing treaties/locks.
    - Convert to RelationshipChangeEvent if valid.
    """

    target_id: str = ""
    new_relationship_type: str = ""  # e.g., "war", "alliance", "trade"
    reason: str = ""  # Context/Casus Belli
    metadata_json: str = "{}"  # Details (trade terms, etc.)


@dataclass(slots=True)
class ResourceTransferIntention(Intention):
    """Intention to transfer resources to another entity.

    Resolution:
    - Validate source has sufficient resources in `resources_json`.
    - Validate target can receive this resource type.
    - Convert to ResourceTransferEvent if valid.
    """

    target_id: str = ""
    resource_type: str = ""  # Must match a key in Project Schema
    amount: float = 0.0


@dataclass(slots=True)
class SpeakIntention(Intention):
    """Intention to communicate with another entity.

    Used for dialogue, negotiation, LLM-to-LLM interaction.
    """

    target_id: str = ""
    message: str = ""
    is_public: bool = False


@dataclass(slots=True)
class CustomIntention(Intention):
    """Generic intention for domain-specific actions.

    Use for actions defined in the Project Manifest that don't fit standard types.
    Example: "Cast Spell", "Hack Terminal", "Hyperjump".
    """

    action_type: str = ""
    parameters_json: str = "{}"


# ============================================================================
# Intention Queue Management
# ============================================================================


@dataclass
class IntentionResult:
    """Result of intention processing returned by Engine."""

    intention_id: str
    status: IntentionStatus
    event_id: Optional[str] = None
    rejection_reason: Optional[str] = None
    blocked_by: Optional[str] = None


# ============================================================================
# Resolution Interface
# ============================================================================


class IntentionResolver:
    """Interface for intention resolution (implemented by Engine)."""

    def validate(self, intention: Intention) -> tuple[bool, Optional[str]]:
        raise NotImplementedError("Engine must implement validate()")

    def check_interrupts(self, intention: Intention) -> Optional[str]:
        raise NotImplementedError("Engine must implement check_interrupts()")

    def convert_to_event(self, intention: Intention, tick: int) -> "Any":
        raise NotImplementedError("Engine must implement convert_to_event()")


# ============================================================================
# Intention Type Registry
# ============================================================================


INTENTION_TYPES: dict[str, type[Intention]] = {
    "move": MoveIntention,
    "attack": AttackIntention,
    "change_relationship": ChangeRelationshipIntention,
    "resource_transfer": ResourceTransferIntention,
    "speak": SpeakIntention,
    "custom": CustomIntention,
}


def get_intention_class(intention_type: str) -> type[Intention]:
    """Get the Intention subclass for a given type."""
    if intention_type not in INTENTION_TYPES:
        raise KeyError(f"Unknown intention type: {intention_type}")
    return INTENTION_TYPES[intention_type]